/**
 * PNG Export for Specter
 *
 * Generates shareable PNG images from terminal output.
 * Parses ANSI colors and renders beautifully styled images
 * optimized for social media sharing.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { type CanvasRenderingContext2D, createCanvas, loadImage } from 'canvas';
import QRCode from 'qrcode';

export interface PngExportOptions {
  width?: number; // Default 1200 (Twitter-optimized)
  height?: number; // Auto-calculated if not provided
  theme?: 'dark' | 'light'; // Default dark
  watermark?: boolean; // Default true - "Generated by Specter"
  padding?: number; // Default 40
  lineHeight?: number; // Default 1.4
  fontSize?: number; // Default 16
  qrUrl?: string; // URL to encode as QR code (bottom-right corner)
  socialFormat?: boolean; // Force 1200x630 (Twitter/LinkedIn card) dimensions
}

// Social media optimal dimensions
export const SOCIAL_DIMENSIONS = {
  width: 1200,
  height: 630, // 1.9:1 aspect ratio - optimal for Twitter/LinkedIn
};

// ANSI color code to hex color mapping
const ansiColors: Record<string, string> = {
  // Standard colors (dark theme)
  '30': '#4a4a4a', // black
  '31': '#ff6b6b', // red
  '32': '#6bcb77', // green
  '33': '#ffd93d', // yellow
  '34': '#6b8cff', // blue
  '35': '#cc6bff', // magenta
  '36': '#6bffff', // cyan
  '37': '#e0e0e0', // white

  // Bright colors
  '90': '#666666', // bright black (gray)
  '91': '#ff8a8a', // bright red
  '92': '#8fe69b', // bright green
  '93': '#ffe566', // bright yellow
  '94': '#8fa8ff', // bright blue
  '95': '#d98aff', // bright magenta
  '96': '#8affff', // bright cyan
  '97': '#ffffff', // bright white
};

// Light theme color overrides
const lightThemeColors: Record<string, string> = {
  '30': '#000000', // black
  '31': '#cc0000', // red
  '32': '#006600', // green
  '33': '#cc8800', // yellow
  '34': '#0000cc', // blue
  '35': '#880088', // magenta
  '36': '#008888', // cyan
  '37': '#333333', // white (dark for contrast)
  '90': '#555555', // bright black
  '91': '#ff0000', // bright red
  '92': '#00aa00', // bright green
  '93': '#ffaa00', // bright yellow
  '94': '#0066ff', // bright blue
  '95': '#aa00aa', // bright magenta
  '96': '#00aaaa', // bright cyan
  '97': '#000000', // bright white (black for contrast)
};

interface TextSegment {
  text: string;
  color: string;
  bold: boolean;
  italic: boolean;
  dim: boolean;
}

interface ParsedLine {
  segments: TextSegment[];
}

/**
 * Parse ANSI escape codes from text
 */
function parseAnsiText(text: string, theme: 'dark' | 'light'): ParsedLine[] {
  const lines: ParsedLine[] = [];
  const colorMap = theme === 'dark' ? ansiColors : lightThemeColors;
  const defaultColor = theme === 'dark' ? '#e0e0e0' : '#333333';

  // Split into lines first
  const rawLines = text.split('\n');

  for (const rawLine of rawLines) {
    const segments: TextSegment[] = [];
    let currentColor = defaultColor;
    let bold = false;
    let italic = false;
    let dim = false;

    // ANSI escape code regex
    const ansiRegex = /\x1b\[([0-9;]+)m/g;
    let lastIndex = 0;
    let match: RegExpExecArray | null;

    while ((match = ansiRegex.exec(rawLine)) !== null) {
      // Add text before this escape code
      if (match.index > lastIndex) {
        const textBefore = rawLine.substring(lastIndex, match.index);
        if (textBefore) {
          segments.push({
            text: textBefore,
            color: dim ? adjustColorForDim(currentColor) : currentColor,
            bold,
            italic,
            dim,
          });
        }
      }

      // Parse the escape code
      const codes = match[1].split(';').map(Number);
      for (const code of codes) {
        if (code === 0) {
          // Reset
          currentColor = defaultColor;
          bold = false;
          italic = false;
          dim = false;
        } else if (code === 1) {
          bold = true;
        } else if (code === 2) {
          dim = true;
        } else if (code === 3) {
          italic = true;
        } else if (code === 22) {
          bold = false;
          dim = false;
        } else if (code === 23) {
          italic = false;
        } else if (colorMap[code.toString()]) {
          currentColor = colorMap[code.toString()];
        } else if (code >= 30 && code <= 37) {
          currentColor = colorMap[code.toString()] || defaultColor;
        } else if (code >= 90 && code <= 97) {
          currentColor = colorMap[code.toString()] || defaultColor;
        }
      }

      lastIndex = ansiRegex.lastIndex;
    }

    // Add remaining text
    if (lastIndex < rawLine.length) {
      const remaining = rawLine.substring(lastIndex);
      if (remaining) {
        segments.push({
          text: remaining,
          color: dim ? adjustColorForDim(currentColor) : currentColor,
          bold,
          italic,
          dim,
        });
      }
    }

    // If no segments, add empty line
    if (segments.length === 0) {
      segments.push({ text: '', color: defaultColor, bold: false, italic: false, dim: false });
    }

    lines.push({ segments });
  }

  return lines;
}

/**
 * Adjust color for dim effect
 */
function adjustColorForDim(hex: string): string {
  // Parse hex color
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);

  // Reduce brightness by 40%
  const dimR = Math.floor(r * 0.6);
  const dimG = Math.floor(g * 0.6);
  const dimB = Math.floor(b * 0.6);

  return `#${dimR.toString(16).padStart(2, '0')}${dimG.toString(16).padStart(2, '0')}${dimB.toString(16).padStart(2, '0')}`;
}

/**
 * Strip ANSI codes from text (for measuring)
 */
function _stripAnsi(text: string): string {
  return text.replace(/\x1b\[[0-9;]*m/g, '');
}

/**
 * Calculate required canvas height based on content
 */
function calculateHeight(
  lines: ParsedLine[],
  _ctx: CanvasRenderingContext2D,
  fontSize: number,
  lineHeight: number,
  padding: number,
  hasWatermark: boolean,
  hasQrCode: boolean = false
): number {
  const lineCount = lines.length;
  const textHeight = lineCount * fontSize * lineHeight;
  const headerHeight = 80; // Space for header/title area
  const watermarkHeight = hasWatermark ? 60 : 0;
  const qrCodeHeight = hasQrCode ? 40 : 0; // Extra space for QR code

  return Math.max(
    400,
    Math.ceil(padding * 2 + headerHeight + textHeight + watermarkHeight + qrCodeHeight)
  );
}

/**
 * Draw rounded rectangle
 */
function drawRoundedRect(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  width: number,
  height: number,
  radius: number
): void {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
}

/**
 * Generate header based on content type
 */
function detectContentType(content: string): 'wrapped' | 'achievements' | 'dna' | 'generic' {
  if (content.includes('WRAPPED') || content.includes('#SpecterWrapped')) {
    return 'wrapped';
  }
  if (content.includes('ACHIEVEMENTS') || content.includes('UNLOCKED')) {
    return 'achievements';
  }
  if (
    content.includes('DNA PROFILE') ||
    content.includes('DOUBLE HELIX') ||
    content.includes('Sequence:')
  ) {
    return 'dna';
  }
  return 'generic';
}

/**
 * Get header info based on content type
 */
function getHeaderInfo(contentType: 'wrapped' | 'achievements' | 'dna' | 'generic'): {
  emoji: string;
  title: string;
  subtitle: string;
  gradient: [string, string];
} {
  switch (contentType) {
    case 'wrapped':
      return {
        emoji: '\u{1F3B5}', // musical note
        title: 'Specter Wrapped',
        subtitle: 'Your Year in Code',
        gradient: ['#1a1a2e', '#16213e'],
      };
    case 'achievements':
      return {
        emoji: '\u{1F3C6}', // trophy
        title: 'Specter Achievements',
        subtitle: 'Your Coding Badges',
        gradient: ['#1a1a2e', '#2d132c'],
      };
    case 'dna':
      return {
        emoji: '\u{1F9EC}', // dna
        title: 'Codebase DNA',
        subtitle: 'Your Unique Fingerprint',
        gradient: ['#1a1a2e', '#0a3d62'],
      };
    default:
      return {
        emoji: '\u{1F47B}', // ghost
        title: 'Specter',
        subtitle: 'Code Intelligence',
        gradient: ['#1a1a2e', '#1a1a2e'],
      };
  }
}

/**
 * Export terminal content to PNG
 */
export async function exportToPng(
  content: string,
  outputPath: string,
  options: PngExportOptions = {}
): Promise<string> {
  const {
    theme = 'dark',
    watermark = true,
    padding = 40,
    lineHeight = 1.4,
    fontSize = 16,
    qrUrl,
    socialFormat = false,
  } = options;

  // Use social media dimensions if requested
  const width = socialFormat ? SOCIAL_DIMENSIONS.width : (options.width || 1200);

  // Detect content type for styling
  const contentType = detectContentType(content);
  const headerInfo = getHeaderInfo(contentType);

  // Parse ANSI codes
  const parsedLines = parseAnsiText(content, theme);

  // Create temporary canvas for measurements
  const tempCanvas = createCanvas(width, 100);
  const tempCtx = tempCanvas.getContext('2d');
  tempCtx.font = `${fontSize}px "JetBrains Mono", "Fira Code", "SF Mono", Menlo, Monaco, "Courier New", monospace`;

  // Calculate height - force social dimensions if requested
  const calculatedHeight = socialFormat
    ? SOCIAL_DIMENSIONS.height
    : (options.height ||
        calculateHeight(parsedLines, tempCtx, fontSize, lineHeight, padding, watermark, !!qrUrl));

  // Create main canvas
  const canvas = createCanvas(width, calculatedHeight);
  const ctx = canvas.getContext('2d');

  // Draw background gradient
  const bgGradient = ctx.createLinearGradient(0, 0, 0, calculatedHeight);
  if (theme === 'dark') {
    bgGradient.addColorStop(0, headerInfo.gradient[0]);
    bgGradient.addColorStop(1, headerInfo.gradient[1]);
  } else {
    bgGradient.addColorStop(0, '#f8f9fa');
    bgGradient.addColorStop(1, '#e9ecef');
  }
  ctx.fillStyle = bgGradient;
  ctx.fillRect(0, 0, width, calculatedHeight);

  // Draw decorative elements
  drawDecorations(ctx, width, calculatedHeight, theme, contentType);

  // Draw content area (terminal-style box)
  const boxX = padding;
  const boxY = 70;
  const boxWidth = width - padding * 2;
  const boxHeight = calculatedHeight - 70 - padding - (watermark ? 50 : 0);

  // Terminal window background
  ctx.fillStyle = theme === 'dark' ? 'rgba(0, 0, 0, 0.4)' : 'rgba(255, 255, 255, 0.9)';
  drawRoundedRect(ctx, boxX, boxY, boxWidth, boxHeight, 12);
  ctx.fill();

  // Terminal window border
  ctx.strokeStyle = theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
  ctx.lineWidth = 1;
  drawRoundedRect(ctx, boxX, boxY, boxWidth, boxHeight, 12);
  ctx.stroke();

  // Draw header bar with dots
  ctx.fillStyle = theme === 'dark' ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)';
  drawRoundedRect(ctx, boxX, boxY, boxWidth, 32, 12);
  ctx.fill();

  // Draw window controls (red, yellow, green dots)
  const dotY = boxY + 16;
  const dotRadius = 6;
  const dotColors = ['#ff5f56', '#ffbd2e', '#27ca40'];
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(boxX + 20 + i * 20, dotY, dotRadius, 0, Math.PI * 2);
    ctx.fillStyle = dotColors[i];
    ctx.fill();
  }

  // Draw title in header
  ctx.font = `bold 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
  ctx.fillStyle = theme === 'dark' ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 0, 0, 0.6)';
  ctx.textAlign = 'center';
  ctx.fillText(`${headerInfo.emoji} ${headerInfo.title}`, width / 2, boxY + 20);

  // Draw content
  ctx.textAlign = 'left';
  let y = boxY + 50;
  const textX = boxX + 20;
  const _maxTextWidth = boxWidth - 40;

  for (const line of parsedLines) {
    let x = textX;

    for (const segment of line.segments) {
      // Set font based on style
      const fontWeight = segment.bold ? 'bold' : 'normal';
      const fontStyle = segment.italic ? 'italic' : 'normal';
      ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px "JetBrains Mono", "Fira Code", "SF Mono", Menlo, Monaco, "Courier New", monospace`;
      ctx.fillStyle = segment.color;

      // Draw text
      ctx.fillText(segment.text, x, y);
      x += ctx.measureText(segment.text).width;
    }

    y += fontSize * lineHeight;
  }

  // Draw watermark
  if (watermark) {
    const watermarkY = calculatedHeight - 25;
    ctx.font = `bold 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
    ctx.fillStyle = theme === 'dark' ? 'rgba(255, 255, 255, 0.4)' : 'rgba(0, 0, 0, 0.4)';
    ctx.textAlign = 'center';

    // Adjust watermark text position if QR code is present
    const watermarkText = qrUrl
      ? '\u{1F47B} Generated by Specter  |  Scan to explore \u2192'
      : '\u{1F47B} Generated by Specter  |  Share your code story';
    const watermarkX = qrUrl ? (width - 100) / 2 : width / 2;
    ctx.fillText(watermarkText, watermarkX, watermarkY);
  }

  // Draw QR code if URL provided
  if (qrUrl) {
    try {
      const qrSize = 80;
      const qrX = width - padding - qrSize;
      const qrY = calculatedHeight - padding - qrSize + 10;

      // Generate QR code as data URL
      const qrDataUrl = await QRCode.toDataURL(qrUrl, {
        width: qrSize,
        margin: 1,
        color: {
          dark: theme === 'dark' ? '#ffffff' : '#000000',
          light: theme === 'dark' ? '#00000000' : '#ffffff00', // transparent background
        },
      });

      // Load and draw QR code image
      const qrImage = await loadImage(qrDataUrl);

      // Draw subtle background for QR code
      ctx.fillStyle = theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
      drawRoundedRect(ctx, qrX - 5, qrY - 5, qrSize + 10, qrSize + 10, 8);
      ctx.fill();

      ctx.drawImage(qrImage, qrX, qrY, qrSize, qrSize);
    } catch (err) {
      // QR code generation failed, continue without it
      console.warn('Failed to generate QR code:', err);
    }
  }

  // Save to file
  const absolutePath = path.resolve(outputPath);
  const buffer = canvas.toBuffer('image/png');
  fs.writeFileSync(absolutePath, buffer);

  return absolutePath;
}

/**
 * Draw decorative background elements
 */
function drawDecorations(
  ctx: CanvasRenderingContext2D,
  width: number,
  height: number,
  theme: 'dark' | 'light',
  contentType: string
): void {
  const alpha = theme === 'dark' ? 0.1 : 0.05;

  // Draw subtle grid pattern
  ctx.strokeStyle =
    theme === 'dark' ? `rgba(255, 255, 255, ${alpha * 0.3})` : `rgba(0, 0, 0, ${alpha * 0.3})`;
  ctx.lineWidth = 1;

  // Vertical lines
  for (let x = 0; x < width; x += 40) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, height);
    ctx.stroke();
  }

  // Horizontal lines
  for (let y = 0; y < height; y += 40) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(width, y);
    ctx.stroke();
  }

  // Draw accent circles based on content type
  const circleColor =
    contentType === 'wrapped'
      ? '#6b5ce7'
      : contentType === 'achievements'
        ? '#f9ca24'
        : contentType === 'dna'
          ? '#00d2d3'
          : '#6b5ce7';

  // Top-right decorative circle
  ctx.beginPath();
  ctx.arc(width - 80, 80, 120, 0, Math.PI * 2);
  ctx.fillStyle = `${circleColor}${Math.floor(alpha * 255)
    .toString(16)
    .padStart(2, '0')}`;
  ctx.fill();

  // Bottom-left decorative circle
  ctx.beginPath();
  ctx.arc(80, height - 80, 100, 0, Math.PI * 2);
  ctx.fillStyle = `${circleColor}${Math.floor(alpha * 0.5 * 255)
    .toString(16)
    .padStart(2, '0')}`;
  ctx.fill();
}

/**
 * Format achievements data for PNG export
 * Returns a plain text representation suitable for rendering
 */
export function formatAchievementsForExport(
  unlocked: Array<{ name: string; emoji: string; description: string }>,
  locked: Array<{ name: string; emoji: string; description: string }>,
  total: number
): string {
  const lines: string[] = [];
  const W = 45;

  lines.push('');
  lines.push('  \u{1F3C6} ACHIEVEMENTS');
  lines.push('');
  lines.push(`\u250c${'\u2500'.repeat(W)}\u2510`);
  lines.push(`\u2502${' UNLOCKED'.padEnd(W)}\u2502`);
  lines.push(`\u251c${'\u2500'.repeat(W)}\u2524`);

  if (unlocked.length === 0) {
    lines.push(`\u2502${' No achievements unlocked yet...'.padEnd(W)}\u2502`);
  } else {
    for (const achievement of unlocked) {
      const line = ` ${achievement.emoji} ${achievement.name} - ${achievement.description}`;
      const truncated = line.slice(0, W);
      lines.push(`\u2502${truncated.padEnd(W)}\u2502`);
    }
  }
  lines.push(`\u2514${'\u2500'.repeat(W)}\u2518`);

  lines.push('');
  lines.push(`\u250c${'\u2500'.repeat(W)}\u2510`);
  lines.push(`\u2502${' \u{1F512} LOCKED'.padEnd(W)}\u2502`);
  lines.push(`\u251c${'\u2500'.repeat(W)}\u2524`);

  if (locked.length === 0) {
    lines.push(`\u2502${' All achievements unlocked!'.padEnd(W)}\u2502`);
  } else {
    for (const achievement of locked) {
      const line = ` ${achievement.emoji} ${achievement.name} - ${achievement.description}`;
      const truncated = line.slice(0, W);
      lines.push(`\u2502${truncated.padEnd(W)}\u2502`);
    }
  }
  lines.push(`\u2514${'\u2500'.repeat(W)}\u2518`);

  // Progress
  lines.push('');
  const percent = Math.round((unlocked.length / total) * 100);
  lines.push(`  Progress: ${unlocked.length}/${total} achievements (${percent}%)`);

  // Progress bar
  const barWidth = 30;
  const filled = Math.round((unlocked.length / total) * barWidth);
  const empty = barWidth - filled;
  const bar = '\u2588'.repeat(filled) + '\u2591'.repeat(empty);
  lines.push(`  ${bar}`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Check if canvas package is available
 */
export async function isPngExportAvailable(): Promise<boolean> {
  try {
    await import('canvas');
    return true;
  } catch {
    return false;
  }
}

/**
 * Get GitHub repository URL from git remote
 * Returns a clean HTTPS URL suitable for QR codes
 */
export async function getRepoUrl(rootDir: string = '.'): Promise<string | null> {
  try {
    const { execSync } = await import('node:child_process');
    const remote = execSync('git config --get remote.origin.url', {
      cwd: rootDir,
      encoding: 'utf8',
    }).trim();

    // Convert SSH URL to HTTPS
    // git@github.com:user/repo.git -> https://github.com/user/repo
    if (remote.startsWith('git@')) {
      const match = remote.match(/git@([^:]+):(.+?)(\.git)?$/);
      if (match) {
        return `https://${match[1]}/${match[2]}`;
      }
    }

    // Already HTTPS, clean up .git suffix
    if (remote.startsWith('https://')) {
      return remote.replace(/\.git$/, '');
    }

    return remote;
  } catch {
    return null;
  }
}

/**
 * Social Share URL Options
 */
export interface ShareUrls {
  twitter: string;
  linkedin: string;
  raw: string;
}

/**
 * Generate social share URLs for PNG exports
 * Returns pre-filled share links for Twitter and LinkedIn
 */
export function generateShareUrls(
  commandType: string,
  repoUrl?: string | null,
  stats?: { healthScore?: number; complexity?: number }
): ShareUrls {
  const projectName = repoUrl ? repoUrl.split('/').pop() || 'my codebase' : 'my codebase';

  // Craft compelling share text based on command type
  const shareTexts: Record<string, string> = {
    health: `\u{1F47B} Just ran specter health on ${projectName}${stats?.healthScore ? ` - scored ${Math.round(stats.healthScore)}/100!` : ''}\n\nGive your codebase a voice: github.com/specter-cli/specter`,
    roast: `\u{1F525} Got absolutely roasted by Specter...\n\nMy codebase called me out and I deserved it \u{1F62D}\n\nTry it: github.com/specter-cli/specter`,
    wrapped: `\u{1F389} My codebase wrapped is here!\n\nSpotify Wrapped but for code - see your year in commits, complexity trends, and more.\n\nTry Specter: github.com/specter-cli/specter`,
    achievements: `\u{1F3C6} Just unlocked new achievements in my codebase!\n\nGameified code quality with Specter\n\nCheck it out: github.com/specter-cli/specter`,
    dna: `\u{1F9EC} My codebase's DNA visualization is wild!\n\nEvery repo has a unique fingerprint.\n\nGenerate yours: github.com/specter-cli/specter`,
    tinder: `\u{1F525} Would you swipe right on my codebase?\n\nSpecter gave me a Tinder profile for my code lol\n\nTry it: github.com/specter-cli/specter`,
    cost: `\u{1F4B0} Just calculated my tech debt in dollars...\n\n${stats?.complexity ? `$${(stats.complexity * 150).toLocaleString()} estimated remediation cost.` : 'The results were... concerning.'}\n\nTry Specter: github.com/specter-cli/specter`,
    default: `\u{1F47B} Just discovered Specter - gives your codebase a voice!\n\n11 personality modes, DORA metrics, roasts, and more.\n\nCheck it out: github.com/specter-cli/specter`,
  };

  const text = shareTexts[commandType] || shareTexts.default;
  const encodedText = encodeURIComponent(text);

  return {
    twitter: `https://twitter.com/intent/tweet?text=${encodedText}`,
    linkedin: `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(repoUrl || 'https://github.com/specter-cli/specter')}&summary=${encodedText}`,
    raw: text,
  };
}
